package main

import (
	"fmt"
	"go/ast"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/jaredallard/cmdexec"
	"go.rgst.io/stencil/pkg/slogext"
	"golang.org/x/tools/go/packages"
)

// goGitlabVersion is the version of go-gitlab to use for code
// generation.
//
// TODO(jaredallard): Read from go.mod
var goGitlabVersion = "v0.109.0"

func main() {
	log := slogext.New()
	if err := entrypoint(log); err != nil {
		log.WithError(err).Error("failed to run codegen")
		os.Exit(1)
	}
}

// getServices returns all of the "Service" fields on the
// [gitlab.Client] provided by go-gitlab.
func getServices(_ slogext.Logger, pkgs []*packages.Package) []string {
	services := make(map[string]struct{}, 0)
	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			for _, decl := range file.Decls {
				decl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}

				for _, spec := range decl.Specs {
					spec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					if spec.Name.Name != "Client" {
						continue
					}

					st, ok := spec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					for _, field := range st.Fields.List {
						for _, name := range field.Names {
							// Check if the type is named "Service"
							typeName := pkg.TypesInfo.TypeOf(name)
							if typeName == nil {
								continue
							}

							spl := strings.Split(typeName.String(), ".")
							shortTypeName := spl[len(spl)-1]
							if !strings.HasSuffix(shortTypeName, "Service") {
								continue
							}

							services[shortTypeName] = struct{}{}
						}
					}
				}
			}
		}
	}

	serviceList := slices.Collect(maps.Keys(services))
	slices.Sort(serviceList)
	return serviceList
}

// generateInterfaces creates an interface for each of the service types
// passed by name to this function. The interfaces are generated using
// 'ifacemaker' and are generated into the root directory of
// the project.
func generateInterfaces(log slogext.Logger, goGitlabDir string, services []string) error {
	files, err := filepath.Glob("*_inf.go")
	if err != nil {
		return fmt.Errorf("failed to glob existing interfaces: %w", err)
	}

	for _, file := range files {
		if err := os.Remove(file); err != nil {
			return fmt.Errorf("failed to remove existing interface: %w", err)
		}
	}

	for _, service := range services {
		log.Infof("Generating interface for %s", service)
		cmd := cmdexec.Command(
			"ifacemaker",
			"-f", goGitlabDir+"/*.go",
			"-s", service,
			"-i", service,
			"-p", "gitlab",
			"-y", service+" is an interface for [gitlab.Client."+service+"]",
			"-o", strings.ToLower(service)+"_inf.go",
		)
		cmd.UseOSStreams(true)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to generate interface for %s: %w", service, err)
		}
	}

	return nil
}

// generateMocks generates mocks for all of the _inf.go files that were
// generated by the generateInterfaces function. The mocks are generated
// using 'mockgen' and are placed in the mocks/ directory.
func generateMocks(log slogext.Logger) error {
	os.RemoveAll("mocks")
	if err := os.Mkdir("mocks", 0o755); err != nil {
		return fmt.Errorf("failed to create mocks directory: %w", err)
	}

	files, err := filepath.Glob("*_inf.go")
	if err != nil {
		return fmt.Errorf("failed to glob existing interfaces: %w", err)
	}

	for _, file := range files {
		log.Infof("Generating mock for %s", file)
		cmd := cmdexec.Command(
			"mockgen",
			"-package=mocks",
			"-source="+file,
			"-destination="+filepath.Join("mocks", file),
		)
		cmd.UseOSStreams(true)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to generate mock for %s: %w", file, err)
		}
	}

	return nil
}

func entrypoint(log slogext.Logger) error {
	// Embedding in the directory was causing issues with the `packages`
	// package.
	tmpDir := filepath.Join(os.TempDir(), "go-gitlab")
	if _, err := os.Stat(tmpDir); os.IsNotExist(err) {
		log.Info("Cloning go-gitlab")
		cmd := cmdexec.Command(
			"git", "clone", "https://github.com/xanzy/go-gitlab",
			"--single-branch", "--branch", goGitlabVersion,
			tmpDir,
		)
		cmd.UseOSStreams(true)
		if err := cmd.Run(); err != nil {
			return err
		}
	}

	log.Infof("Using go-gitlab from %s", tmpDir)

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax | packages.NeedFiles,
		Dir:  tmpDir,
	})
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return fmt.Errorf("no packages found")
	}

	services := getServices(log, pkgs)

	if err := generateAliases(log, services, pkgs); err != nil {
		return err
	}

	if err := generateInterfaces(log, tmpDir, services); err != nil {
		return err
	}

	if err := generateMocks(log); err != nil {
		return err
	}

	log.Info("Formatting generated code")
	cmd := cmdexec.Command("mise", "run", "fmt")
	cmd.UseOSStreams(true)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	return nil
}
