// Copyright (C) 2024 gitlab contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program. If not, see
// <https://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: LGPL-3.0

package main

import (
	"fmt"
	"go/ast"
	"os"
	"text/template"

	"go.rgst.io/stencil/pkg/slogext"
	"golang.org/x/tools/go/packages"
)

var aliasesTpl = `// Code generated by ./tools/codegen; DO NOT EDIT.
package gitlab

import "github.com/xanzy/go-gitlab"

{{- range .Aliases }}

// {{ .Name }} is an alias to [gitlab.{{ .Name }}]
type {{ .Name }} = gitlab.{{ .Name }}

{{- end }}
`

// Alias is a type alias to create.
type Alias struct {
	// Name is the name of an exported type to create an alias for.
	Name string
}

// generateAliases generates type aliases for all exported types in the
// go-gitlab package. This excludes any service types.
func generateAliases(log slogext.Logger, services []*Service, pkgs []*packages.Package) error {
	aliasesTpl, err := template.New("aliases").Parse(aliasesTpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Convert the services to a map for faster lookups.
	serviceMap := make(map[string]struct{}, len(services))
	for _, service := range services {
		serviceMap[service.Name] = struct{}{}
	}

	// Always skip the Client type.
	serviceMap["Client"] = struct{}{}

	aliases := make([]Alias, 0)
	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			for _, decl := range file.Decls {
				decl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}

				for _, spec := range decl.Specs {
					spec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					// Skip services.
					if _, ok := serviceMap[spec.Name.Name]; ok {
						continue
					}

					// Skip non-exported types.
					if !spec.Name.IsExported() {
						continue
					}

					aliases = append(aliases, Alias{
						Name: spec.Name.Name,
					})
				}
			}
		}
	}

	log.Infof("Created %d type aliases", len(aliases))
	f, err := os.Create("aliases.go")
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	if err := aliasesTpl.Execute(f, map[string]any{
		"Aliases": aliases,
	}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
