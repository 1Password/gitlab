// Code generated by MockGen. DO NOT EDIT.
// Source: packagesservice_inf.go
//
// Generated by this command:
//
//	mockgen -package=mocks -source=packagesservice_inf.go -destination=mocks/packagesservice_inf.go
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gitlab "github.com/xanzy/go-gitlab"
	gomock "go.uber.org/mock/gomock"
)

// MockPackagesService is a mock of PackagesService interface.
type MockPackagesService struct {
	ctrl     *gomock.Controller
	recorder *MockPackagesServiceMockRecorder
}

// MockPackagesServiceMockRecorder is the mock recorder for MockPackagesService.
type MockPackagesServiceMockRecorder struct {
	mock *MockPackagesService
}

// NewMockPackagesService creates a new mock instance.
func NewMockPackagesService(ctrl *gomock.Controller) *MockPackagesService {
	mock := &MockPackagesService{ctrl: ctrl}
	mock.recorder = &MockPackagesServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackagesService) EXPECT() *MockPackagesServiceMockRecorder {
	return m.recorder
}

// DeletePackageFile mocks base method.
func (m *MockPackagesService) DeletePackageFile(pid any, pkg, file int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg, file}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeletePackageFile", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeletePackageFile indicates an expected call of DeletePackageFile.
func (mr *MockPackagesServiceMockRecorder) DeletePackageFile(pid, pkg, file any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg, file}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePackageFile", reflect.TypeOf((*MockPackagesService)(nil).DeletePackageFile), varargs...)
}

// DeleteProjectPackage mocks base method.
func (m *MockPackagesService) DeleteProjectPackage(pid any, pkg int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectPackage", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectPackage indicates an expected call of DeleteProjectPackage.
func (mr *MockPackagesServiceMockRecorder) DeleteProjectPackage(pid, pkg any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectPackage", reflect.TypeOf((*MockPackagesService)(nil).DeleteProjectPackage), varargs...)
}

// ListGroupPackages mocks base method.
func (m *MockPackagesService) ListGroupPackages(gid any, opt *gitlab.ListGroupPackagesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupPackage, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroupPackages", varargs...)
	ret0, _ := ret[0].([]*gitlab.GroupPackage)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroupPackages indicates an expected call of ListGroupPackages.
func (mr *MockPackagesServiceMockRecorder) ListGroupPackages(gid, opt any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupPackages", reflect.TypeOf((*MockPackagesService)(nil).ListGroupPackages), varargs...)
}

// ListPackageFiles mocks base method.
func (m *MockPackagesService) ListPackageFiles(pid any, pkg int, opt *gitlab.ListPackageFilesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.PackageFile, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageFiles", varargs...)
	ret0, _ := ret[0].([]*gitlab.PackageFile)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListPackageFiles indicates an expected call of ListPackageFiles.
func (mr *MockPackagesServiceMockRecorder) ListPackageFiles(pid, pkg, opt any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageFiles", reflect.TypeOf((*MockPackagesService)(nil).ListPackageFiles), varargs...)
}

// ListProjectPackages mocks base method.
func (m *MockPackagesService) ListProjectPackages(pid any, opt *gitlab.ListProjectPackagesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Package, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectPackages", varargs...)
	ret0, _ := ret[0].([]*gitlab.Package)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectPackages indicates an expected call of ListProjectPackages.
func (mr *MockPackagesServiceMockRecorder) ListProjectPackages(pid, opt any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectPackages", reflect.TypeOf((*MockPackagesService)(nil).ListProjectPackages), varargs...)
}
